# Declarative UI for M5Stack

**企画名** : Declarative UI for M5Stack - HTML/JSX Like な記法でマイコンの UI を製作できる新たな言語を開発する試み -
**班番号** : RWC24-group26
**開発者** : 丸山 拓真

## 1. プロジェクト概要

### 1.1 背景

昨今、Web フロントエンド分野においては、React 、 Next.js や Remix.js など、コンポーネントを主体にフロントエンド・画面を開発することができるライブラリやフレームワークが次々と誕生しており、一般企業においてもその技術が広く支持されはじめていることは明白である。画面の設計・開発は、手間のかかる作業である。しかし、宣言的 UI を用いれば、コンポーネントと呼ばれる部品単位で容易に構成でき、コンポーネント単位で再利用やテストができるため、前項の手間を少し、あるいは大幅に緩和している。テストツールも playwright や storybook など、次々と登場している。しかし、マイコンや、組み込みなどの分野は、その制約から、フロントエンド技術からは遠く離れているように見える。

### 1.2 目的

本ソフトウェアは、マイコン上で動作する、宣言的 UI を念頭に置いた言語とその処理系である。フロントエンド技術をマイコンへ持ち込み、宣言的 UI の利点を生かした処理系を開発する。これによって、フロントエンド技術者のマイコン開発の参入をより容易にし、また宣言的 UI のマイコン分野での発展に寄与する。前述の React 等との最大の違いは、言語そのものが宣言的 UI を念頭に置いているということである。実行方式は中間表現を用いた実行方式を採用する。中間表現は、構文木巡回による処理系と、アセンブリレベルでの処理系のそれぞれの利点・難点を調整し、その中庸を狙う方式である。そのため、構文木巡回による処理の遅さと、アセンブリレベルでの実装の困難さ、移植の難しさのそれぞれの難点をカバーすることができる[^1]。また、言語そのものが HTML Like な記法を受理できるように構文解析表を構築し、DOM の構築にあたっても専用の命令を用意することで、処理系と一体化した UI レンダリングを可能とする。

```
function fibonacci = (int num) => {
    if (num <= 1) {
        return num;
    };

    return fibonacci(num - 2) + fibonacci(num - 1);
};

function top = () => {
    return (<div>
        <p style={{ fontSize : 3};}> FibonacciCalc </p>
        <p style={{ fontSize : 7};}> { fibonacci(5); } </p>
    </div>);
};

top();

```

図 1 原始プログラム

本言語のサンプルコードを図 1 に示す。まず目につくのは、HTML Like の記法ができるということである。この記法は本言語において中心的な役割を持ち、極めて直感的な書き方で画面の開発ができる。すなわち宣言的に記述することができるというのである。通常の C++言語で M5Stack の画面を開発しようとしたとき、きわめて手続き的で大変な書き方をしなければならない。次に目につくのは、この言語がきわめて短期間で開発された言語であるにもかかわらず、アロー関数を実現しており、さらにアロー関数で再帰関数を実現しているということである。再帰関数の実現は、言語開発において、一筋縄ではいかない。理由としては、特にアロー関数のような、関数を変数に代入するような関数制御を持つ言語であれば、関数が生成された時点ではどの名前も付与されていない無名関数であり、そのまま関数の中を解析しても、再帰呼び出しを行う関数が入った変数を見つけることができないためである。本言語では、先に左辺式を暫定的に解析したあと、右辺式を解析し、再度左辺式を解析し左辺式の宛先に右辺式の結果を代入するという処理を行い、この再帰関数の問題を解決している。もちろん、再度解析する場合は効率よく解析ができるように配慮している。

## 2. プロジェクトの成果物

### システムの概要

大きく 4 つに分かれる。構文解析に必要な、本言語の構文規則を定める構文解析表等を統括するモジュール、原始プログラムを中間表現に変換する処理を行う開発コンピューター側で実行する処理系プログラム、中間表現を実際に M5Stack 上で実行する仮想 VM プログラム、および、そのシリアル通信による転送や、その m5stack での実行状況を確認するため、開発コンピューターと m5stack でやりとりを行うシリアル通信統括プログラムである。以降、それぞれを構文規則定義部、処理系 、仮想 VM、QuickLook とする。また、独自の中間表現についても説明する。

### 2.1 構文規則定義部

##### 2.1.1 文脈自由文法

```
<S> ::= <EL>
<EL> ::= <E> *
<E> ::= <value_definition> ";" | <right> ";" | <left> "=" <right> ";" | <ifexpr> ";" | <DEFINITION> ";" | <for> ";" | <return> ";"| <break> ";" | <continue> ";"

<left> ::= <expression> | <value_definition>
<right> ::= <logic_or> | <json> | <new_class> | <function> | <HTML>

<logic_or> ::= <logic_or> "||" <logic_and> | <logic_and>
<logic_and> ::= <logic_and> "&&" <comparison_equal> | <comparison_equal>

<comparison_equal> ::= <comparison_equal> "==" <comparison> | <comparison_equal> "!=" <comparison> | <comparison>
<comparison> ::= <comparison> "<" <expr> | <comparison> "<=" <expr> | <comparison> ">" <expr> | <comparison> ">=" <expr> | <expr>

<expr> ::= <expr> "+" <term> | <expr> "-" <term> | <term>
<term> ::= <term> "\*" <factor> | <term> "/" <factor> | <term> "%" <factor> | <factor>
<factor> ::= <expression> | "(" <right> ")" | <number> | <text> | <array>

<value_definition> ::= TYPE <value_name>

<expression> ::= <identifier> | <identifier> <rest>
<rest> ::= <property> | <property> <rest>
<property> ::= <dot_property> | <array>
<dot_property> ::= "." <identifier>
<identifier> ::= <value_name> | <function_message_passing> | "(" <expression> ")"

<number> ::= NUM
<text> ::= """ TEXT """ | "'" TEXT "'" | """ NUM """ | "'" NUM "'" | """ """ | "'" "'"
<key> ::= """ TEXT """ | "'" TEXT "'" | """ NUM """ | "'" NUM "'" | TEXT | NUM
<value_name> ::= TEXT

<ifexpr> ::= <if_while> | <if_while> <else>
<if_while> ::= "if" "(" <right> ")" <block> | "while" "(" <right> ")" <block>
<else> ::= "else" "if" "(" <right> ")" <block> <else> | "else" <block> |

<function> ::= "(" <argument> ")" "=>" <block>

<function_message_passing> ::= <value_name> "(" <array_line> ")" | <value_name> "(" ")"
<new_class> ::= "new" TYPE "(" <array_line> ")" | "new" TYPE "(" ")"

<argument> ::= <value_definition> "," <argument> | <value_definition> |

<Efor> ::= <value_name> | <value_definition> "=" <right> | <value_name> "=" <right>
<for> ::= "for" "(" <Efor> ";" <logic_or> ";" <Efor> ")" <block>
<return> ::= "return" | "return" <right>
<break> ::= "break"
<continue> ::= "continue"

<block> ::= "{" <EL> "}"

<DEFINITION> ::= DEFINITION TYPE <block> | DEFINITION TYPE "extends" TYPE <block>

<HTML> ::= <HTML_tag_start> <HTML_children> <HTML_tag_end> | <HTML_tag_single>
<HTML_children> ::= <HTML> <HTML_children> | TEXT | <block> |

<HTML_tag_start> ::= "<" TEXT <HTML_attribute> ">" | "<" TEXT ">"
<HTML_tag_end> ::= "</" TEXT ">"
<HTML_tag_single> ::= "<" TEXT <HTML_attribute> "/>" | "<" TEXT "/>"
<HTML_attribute> ::= <value_name> "=" <block> | <value_name> "=" <block> <HTML_attribute>

<json> ::= "{" <json_line> "}"
<json_line> ::= <json_line> "," <json_element> | <json_element> |
<json_element> ::= <key> ":" <right>

<array> ::= "[" <array_line> "]"
<array_line> ::= <array_line> "," <right> | <right>
```

図 2 構文規則

本言語の構文規則を図 2 に示す。この構文定義は、独自の拡張 BNF によって書かれている。字句解析によって得られる`NUM`や`TEXT`、`DEFINITION`、`TYPE`などのラベルに依存した構文定義が可能であり、バーティカルバー記号によって、いずれかの構文を適用するという表現や、アスタリスク記号によって、複数回許容するという表現ができる。独自の拡張 BNF を解釈し、通常の BNF に落とし込むプログラムも自作しており、これらの構文規則を、シームレスに従来の LR(1)法に関連するプログラムに使用することができる。

図 2 に記載されている`<HTML>`や`<json>`の非終端記号と右辺の構文定義群は、本言語の大きな特徴である。HTML Like な記法や json like な記法が、本言語の構文規則にそのまま組み込まれているのである。これは、HTML 要素や json 要素をシームレスに構文解析できるということである。この手法は、構文解析表が肥大化するというデメリットがあるが、別途 HTML パーサーや json パーサーのような独立したパーサーを作成する必要がないという大きなメリットがあり、現時点ではそのメリットを大きく享受することができる。

##### 2.1.2 LR(1)法

本言語の構文解析のための構文解析表を作成するアルゴリズムは、LR(1)法を用いた。これはボトムアップ構文解析の一種であり、構文解析できる文法の範囲が非常に広く、強力な構文解析アルゴリズムである。LR(1)法に限らず、LL 法や、LR 法、LALR 法など多くの構文解析アルゴリズムの本質は、図 2 ような 構文規則を、決定性有限オートマトンを経て、状態遷移を表すデータ構造に変換することである。状態遷移を表すデータ構造は、一般的に構文解析表と呼ばれることが多い。これは一般的な二次元的な表であり、 Action 表と Goto 表によって構成されれ、Action 表には shift 動作や reduce 動作、accept 動作に関する記載がなされている[^2] [^3]。以降、 Action 表、Goto 表をすべて含めて構文解析表と呼ぶ。

### 2.2 処理系

処理系に関するプログラムは、全て C++言語で記述した。

##### 2.2.1 字句解析モジュール

字句解析は、原始プログラムたる連続した文字列を、のちに行う構文解析アルゴリズムを適用するときに、その構文解析において負担がならないようにある程度の粒度に分割し、構文解析の助けになるようラベルを設定する処理である[^4]。たとえば、`int hello = 1024` という原始プログラムが入力されたとき、 `int` `hello` `=` `1024` のように分割し、それぞれにある程度のラベルを振り分ける。この場合の例としては、`型名` `テキスト` `記号` `数値` のようにラベリングをするのである。また、今回は暫定的に`テキスト`としたが、`変数名`とするなど、もっと細分化したラベルを振り分けても良い。原理上は、構文解析と統一することはできるが、その場合は構文解析が担う役割が肥大化してしまうのである。また、分割したトークンの集まりを、以降トークン列と呼ぶ。

##### 2.2.2 構文解析モジュール

構文解析は、字句解析で分割されたトークン列とラベルを受け取り、図 2 のような構文規則に乗っ取って、解析木・抽象構文木に変換するアルゴリズムである。構文木のような木構造に落とし込む理由は、原始プログラムのトークン列同士の関係性を表現するために便利なためである。さらに、木構造は簡単な配列構造や構造体等によって表現でき、プログラムの実装過程において実装との親和性が非常に高く、その利便性を享受しやすいため、ほとんどの言語実装で構文木のような木構造に落とし込むという作業は一般的に行われる。

本言語の構文解析は、2.1.2 によって構築された構文解析表に、字句解析過程を経たトークン列を参照し、スタック構造を活用しつつ、木構造を構築することによって行われる。構文解析表の Action 表に記載されている、accept 動作を記述している表の要素を参照した場合、構文解析に成功したということおよび構築した木構造を報告する。この木構造が解析木や構文木なのである。いずれの動作も存在しない、空の要素を参照した場合は、構文解析に失敗したと報告する。

LR(1)法によって出力される純粋な木構造は、非終端記号など、後の意味解析にとって不要なノードを含む。言語処理系によっては、この非終端記号をすべて削除し、純粋な終端記号で構築される抽象構文木にする場合もあるが、本言語であは、かっこ記号など、構文木に親子関係等によってすでにその意味が埋め込まれ、意味解析に完全に不要となるノードは削除しつつ、一部の意味解析の手助けとなる非終端記号を残し、解析木と抽象構文木の中庸を取る手法を用いている。

##### 2.2.3 意味解析モジュール

意味解析は、前述の構文解析アルゴリズムによって生成された構文木をもとに、意味的な誤りを検査し、中間表現に変換するアルゴリズムのことである。中間表現の仕様については 2.3 にて述べる。意味解析には、大きく 4 つの役割が期待されている。第一に、複雑な構文解析のような非常に奇妙なアルゴリズムを仮想 VM において実行する必要がないようにすることである。第二に、if や while などの、基本的な条件分岐構文や、ループ構文などを解釈し、jump 命令といった簡素な形で表現することである。単純な if や while のようなものであれば、簡素な命令変換の範疇に収まるが、else if や else 文などのような、きわめて高度な構文を実現するためには、この過程は欠かせない。第三に、定義されていない変数や関数の呼び出しを防止するということである。第四に、若干の型検査を行うということである。第三と第四については、意味解析を担うモジュールに、変数・型を管理するテーブルとその管理を担うモジュールを作成し、そのテーブルへの変数情報の書き込み、参照で実現することができる。このテーブルは、本言語においては、のちに出てくる仮想 VM での VM 変数テーブルと明確に分けるため、型定義テーブルと呼称している。

### 2.3 中間表現

```

250                 # プログラムを開始する

240 1               # fibonacci関数の定義を開始する
030 100 2           # スタックマシンのトップにある要素をpopし、VM 変数テーブル2番地に移動する命令
040 100 2           # VM 変数テーブル2番地にある要素をスタックマシンにpushする。最適化する必要のある命令である。(5.1について述べる)
010 100 1           # int型数値である「1」をスタックマシンにpushする。一部の命令で、第二要素は型である。
117 2               # 左のオペランドが右のオペランドより小さいか等しい場合はそのまま次の列に進む。大きい場合。label 2番の列にjumpする。
040 100 2
050 0               # label 0番の列にjumpする。
050 2               # label 2番の列にjumpする。
051 2               # label 2番を設定する
040 100 2
010 100 2
101                 # スタックマシンの上位2つをpopし、引き算を行い、結果をスタックマシンにpushする
040 700 0           # 関数をスタックマシンに積む。700は関数を操作する型である。
020                 # スタックマシンの最上位の関数をpopし、呼び出す
040 100 2
010 100 1
101
040 700 0
020
100                 # 足し算
050 0
051 0
241                 # fibonacci関数の定義を終了する

240 2               # top関数の定義を開始する
130 div 0           # HTMLタグを開始する
010 100 3
010 200 fontSize    # 200は文字列を表す
140                 # json構築命令である スタックを2つ取得して構築した 組の参照をスタックに積む
010 200 style
130 p 1
010 200 FibonacciCalc
133                 # スタッフのトップにある内容をpopしhtmlの要素の内容として設定する
132                 # HTMLタグを終了する
010 100 7
010 200 fontSize
140
010 200 style
130 p 1
010 100 5
040 700 0
020
132
132
050 3
051 3
241                 # top関数の定義を終了する

245                 # グローバルスコープの定義を開始する

010 700 1           # 最初に実行される
030 700 0
010 700 4
030 700 3
040 700 3
020                 #スタッフマシン最上位の関数を実行する

246                 # グローバルスコープの定義を終了する

# フラットパーサーが解析を行いやすいように、変数・関数の情報を列挙する
244 0 1 -1 -1 700 1 700 4 700 0 700 3
244 1 0 1 0 100 2
244 2 0 4 0

251                 # プログラムを終了する
```

図 3 中間表現

図 1 の原始プログラムに対し、2.2.1 ~ 2.2.3 の各アルゴリズムを適用することによって出力される中間表現を図 3 に示す。上記はすべて 10 進数である。通常は 16 進数に変換して中間表現に書き込むが、人間がわかりやすいように 10 進数のまま出力している。ハッシュタグ記号はコメントである。本処理系では、ハッシュタグ記号から始まる列が無視されるようになっているが、本レポートにおいては便宜上、ハッシュタグ記号以降の文字を改行まで無視するものとする。

中間表現は、スタックを操作するものと、後に述べる仮想 VM での VM 変数テーブルを制御する役割を主として担う。

### 2.4 仮想 VM

仮想 VM に関するプログラムは、全て C++ 言語で記述した。

##### 2.4.1 中間表現走査モジュール(フラットパーサー)

中間表現は、複雑な字句解析や構文解析を仮想 VM 側で行う必要がないように設計している。そのため、きわめて単純な文字列処理で中間表現を走査することができる。本言語では、その性質から、フラットパーサーと呼称している。

##### 2.4.2 スタックマシン

スタックマシンは、中間表現を実行するうえで重要な仮想的な機械である。四則演算命令、関数呼出し命令、比較命令等はすべてこのスタックマシンによって実現する。

##### 2.4.3 コールスタック

コールスタックは、スタック構造を用いて、関数等によって発生するスコープの管理を行う。

##### 2.4.4 VM 変数テーブル

VM 変数テーブルという名称は、一般的ではないが、処理系において型定義などを管理する型定義テーブルと明確に区別し、混同しないため、本レポートにおいては VM 変数テーブルと呼称する。

本言語では、共用体と nullpointer を用いた実装をしている。

##### 2.4.5 DOM モジュール

中間表現において、HTML タグを開始・終了する命令に応じて DOM (Document Object Model) が生成される。DOM は木構造であり、これはブラウザでの一般的な DOM と同じように、この構造を用いて画面要素の管理、配置、座標決定を行う。

##### 2.4.6 DOM レンダリング

2.4.5 において前述した DOM 構造をもとに、m5stack 上でレンダリングする。最終的には、一般的な C++で直に M5Stack の LCD を制御する場合と同じように、M5.Lcd ライブラリを用いて行う。要は、この言語は M5.Lcd ライブラリの巨大なラッパーということなのである。

### 2.5 QuickLook

コンソール上で操作したい内容（コマンド）の入力を受け付け m5stack に送信する処理と、m5stack から送られてきたシリアル通信の内容を表示する機能を有する。今回は Python 言語を用い、pyserial ライブラリを用いたが、特段の難しい処理は行っていないため、serial 通信を制御できれば開発者が各々その環境に併せて代替可能である。

## 3. プロジェクトの進行

言語の開発というのは、その開発する目標を都度定めなければ、無限のリソース（時間・人月・場合によっては費用・・・）を使用してしまい、開発方針が迷走してしまう。そこで、本言語の開発においては、フィボナッチ数列を計算し、それを HTML Like な文法で画面上に表示するという目標を設定し、それを実現するべく努力し、実際にこの目標は達成した。

## 4. 担当と貢献

- **丸山 拓真** プロジェクト全般を担当

## 5. 問題点と課題

### 5.1 最適化

本言語は、最適化のプロセスを実装していない。そのため、メモ化なしフィボナッチ数列の第 10 項の計算を行おうとすると、1 分程度の時間を要する。メモ化なしフィボナッチ数列の実行には再帰関数が 100 回程度呼び出されることを考慮しても、1 分程度時間を要することは、改善するべき事項である。この問題を解決するには、中間表現の命令数を削減することや、仮想 VM の処理手順を効率化することが考えられる。特に、ローカル変数記録領域からスタックに差し込む命令の直後、再びローカル変数記憶領域に差し戻す命令や、またその逆のような、明らかに非効率な中間表現の命令が出現することを確認している。これらを削除することによって、容易に命令数の削減を実現することができる。また、スタックに移動する命令等は仮想 VM の実装上、少々コストが高いため、根本的に仮想 VM の実装も見直す必要がある。

## 6. 参考リスト

[^1]: Robery Nystrom 著 吉川邦夫 訳 ,CRAFTING INTERPRETERS インタプリタの作り方 -言語設計/開発の基本と 2 つの方式による実装-,株式会社インプレス,2023 年
[^2]: 大堀淳, LR 構文解析の原理, コンピュータソフトウェア, vol.31, no.1, pp. 1_30 - 1_42, 2014 年
[^3]: Andrew W Apple 著 神林 靖・滝本 宗宏 翻訳 ,最新コンパイラ構成技法(⽇本語訳) Modern Compiler Implementation in ML New Edition , 翔泳社 , 2009 年
[^4]: ⼭下義⾏ 著 ,コンパイラ⼊⾨ -構⽂解析の原理と lex yacc C ⾔語による実装- ,サイエンス社, 2008 年
